<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to CompSci17_SNA’s documentation! &mdash; CompSci17_SNA 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="CompSci17_SNA 0.1 documentation" href="#" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="welcome-to-compsci17-sna-s-documentation">
<h1>Welcome to CompSci17_SNA&#8217;s documentation!<a class="headerlink" href="#welcome-to-compsci17-sna-s-documentation" title="Permalink to this headline">¶</a></h1>
<p><strong>Welcome to the Documentation</strong>
To view the Graph Module documentation, please use the &#8220;Index&#8221; or &#8220;Module Index&#8221; links below.</p>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span>Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span>Module Index</span></a></li>
</ul>
<p><strong>API</strong>
The Django View API currently only supports three API calls.</p>
<p>The base URL for the API is <a class="reference external" href="http://localhost/vis/">http://localhost/vis/</a> or <a class="reference external" href="http://127.0.0.1/vis/">http://127.0.0.1/vis/</a></p>
<p><strong>GET</strong> /reddit <em>or</em> /slashdot <em>or</em> /enron <em>or</em> /reload
This API call will load the given dataset into the view. This is done by
1. Loading the given dataset into the graph module on the server side
2. Reloading the web view</p>
<p><strong>GET</strong> /load_graph.json
This API call will trigger a JSON response which will be interpreted by D3 to visualise the graph. The server will pick up the currently loaded graph, use the graph.dump_graph() method to generate a JSON file in a format that D3 can read, and pass this in its response to the GET request.</p>
<p><strong>GET</strong> /algorithm
<em>Query Strings</em> <strong>(Required)</strong>
?type=
Valid values:</p>
<blockquote>
<div><p>&#8216;node_count&#8217;; Returns the Node Count of the Graph</p>
<p>&#8216;edge_count&#8217;; Returns the Edge Count of the Graph</p>
<p>&#8216;diameter&#8217;;  Returns the Diameter of the Graph</p>
<p>&#8216;minimum_average_path&#8217;;  Returns the Minimum Average Path of the Graph</p>
<p>&#8216;mode_path_length&#8217;; Returns the Mode Path Length of the Graph</p>
<p>&#8216;average_edges_per_node&#8217;; Returns the Average Edges Per Node in the Graph</p>
<p>&#8216;discover_components&#8217;; Runs DFS to discover nodes, and returns a nested list of components.</p>
<p>&#8216;acc&#8217;; Returns the average clustering coefficient of the graph</p>
<p>&#8216;scc&#8217;; Returns the strongly connected components of the graph (as a nested list)
&#8216;holes&#8217;;</p>
</div></blockquote>
<p>This request will perform the algorithm given in the &#8220;type&#8221; query string, and return a formatted string response.</p>
<p><strong>POST</strong> /algorithm
<em>Query Strings</em>
?type=  <strong>(Required)</strong>
&#8216;spl&#8217;; This computes the shortest path length between the two nodes given. input1 is the source node and input2 is the sink.</p>
<p>&#8216;dfs&#8217;; This runs Depth First Search with the node given in input1 as the source.</p>
<p>&#8216;ek&#8217;; This runs Edmonds Karp to discover the maximum flow between the two nodes input1(source) and input2 (sink).</p>
<p>&#8216;lcc&#8217;: This will compute the local clustering coefficient for the node passed as input1</p>
<p>&#8216;mcmf&#8217;; This runs Tarjan&#8217;s algorithm to discover the Min Cut Maximum Flow between the two nodes input1(source) and input2 (sink).</p>
<p>&amp;input1=     <strong>(Required)</strong>
&amp;input2=     <strong>(Optional)</strong></p>
<span class="target" id="module-graph_sna"></span><span class="target" id="module-graph_sna.graph"></span><span class="target" id="module-graph_sna.graph.graph"></span><dl class="class">
<dt id="algorithms.GraphAlgorithms">
<em class="property">class </em><code class="descclassname">algorithms.</code><code class="descname">GraphAlgorithms</code><a class="headerlink" href="#algorithms.GraphAlgorithms" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="algorithms.GraphAlgorithms.SCC_aux">
<code class="descname">SCC_aux</code><span class="sig-paren">(</span><em>u</em>, <em>low</em>, <em>disc</em>, <em>stackMember</em>, <em>st</em>, <em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#algorithms.GraphAlgorithms.SCC_aux" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for strongly connected components.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="algorithms.GraphAlgorithms.average_edges_per_node">
<code class="descname">average_edges_per_node</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#algorithms.GraphAlgorithms.average_edges_per_node" title="Permalink to this definition">¶</a></dt>
<dd><p>An average of the degree of each node.
:param graph:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="algorithms.GraphAlgorithms.collect_flow">
<code class="descname">collect_flow</code><span class="sig-paren">(</span><em>path</em>, <em>residual_capacity_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#algorithms.GraphAlgorithms.collect_flow" title="Permalink to this definition">¶</a></dt>
<dd><p>This method identifies how much flow is available through a given path and removes it from the
residual capacity
:return:</p>
</dd></dl>

<dl class="method">
<dt id="algorithms.GraphAlgorithms.depth_first_search">
<code class="descname">depth_first_search</code><span class="sig-paren">(</span><em>graph</em>, <em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#algorithms.GraphAlgorithms.depth_first_search" title="Permalink to this definition">¶</a></dt>
<dd><p>An implementation of DFS. Primarily used for the discover_components algorithm.
:param graph:
:param source:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="algorithms.GraphAlgorithms.diameter">
<code class="descname">diameter</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#algorithms.GraphAlgorithms.diameter" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum minimum path that exists in the graph
:param graph:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="algorithms.GraphAlgorithms.discover_components">
<code class="descname">discover_components</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#algorithms.GraphAlgorithms.discover_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses DFS to identify components.
:param graph:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="algorithms.GraphAlgorithms.edge_count">
<code class="descname">edge_count</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#algorithms.GraphAlgorithms.edge_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of edges in the graph.
:param graph:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="algorithms.GraphAlgorithms.edmonds_karp">
<code class="descname">edmonds_karp</code><span class="sig-paren">(</span><em>graph</em>, <em>source</em>, <em>sink</em><span class="sig-paren">)</span><a class="headerlink" href="#algorithms.GraphAlgorithms.edmonds_karp" title="Permalink to this definition">¶</a></dt>
<dd><p>An implementeation of Edmonds Karp&#8217;s algorithm for
:param graph:
:param source:
:param sink:
:return:
Psuedocode used: <a class="reference external" href="https://brilliant.org/wiki/edmonds-karp-algorithm/#algorithm-pseudo-code">https://brilliant.org/wiki/edmonds-karp-algorithm/#algorithm-pseudo-code</a></p>
</dd></dl>

<dl class="method">
<dt id="algorithms.GraphAlgorithms.median_path_length">
<code class="descname">median_path_length</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#algorithms.GraphAlgorithms.median_path_length" title="Permalink to this definition">¶</a></dt>
<dd><p>The ‘central’ or median path length.
:param graph:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="algorithms.GraphAlgorithms.min_cut_max_flow">
<code class="descname">min_cut_max_flow</code><span class="sig-paren">(</span><em>graph</em>, <em>source</em>, <em>sink</em><span class="sig-paren">)</span><a class="headerlink" href="#algorithms.GraphAlgorithms.min_cut_max_flow" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the cut along the graph which contains the critical edges for the flow.
As shown in the max-flow min-cut theorem, the weight of this cut equals the maximum amount of flow
that can be sent from the source to the sink in the given network.
:param graph:
:param max_flow:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="algorithms.GraphAlgorithms.minimum_average_path">
<code class="descname">minimum_average_path</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#algorithms.GraphAlgorithms.minimum_average_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the average of the minimum paths of all the nodes.
:param graph:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="algorithms.GraphAlgorithms.mode_path_length">
<code class="descname">mode_path_length</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#algorithms.GraphAlgorithms.mode_path_length" title="Permalink to this definition">¶</a></dt>
<dd><p>The most common path length
:param graph:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="algorithms.GraphAlgorithms.node_count">
<code class="descname">node_count</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#algorithms.GraphAlgorithms.node_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of nodes in the graph. Regardless of whether they are connected or not.
:param graph:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="algorithms.GraphAlgorithms.shortest_path_length">
<code class="descname">shortest_path_length</code><span class="sig-paren">(</span><em>graph</em>, <em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#algorithms.GraphAlgorithms.shortest_path_length" title="Permalink to this definition">¶</a></dt>
<dd><p>An implementation of Dijkstra&#8217;s algorithm which returns the shortest path length from a given node to all other nodes.
:param graph:
:param source:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="algorithms.GraphAlgorithms.strongly_connected_components">
<code class="descname">strongly_connected_components</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#algorithms.GraphAlgorithms.strongly_connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/">https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/</a>
A strongly connected component is maximal subgraph of a directed graph such that for every pair of vertices  u, v
in the subgraph, there is a directed path from u to v and a directed path from v to u.
We use Tarjan&#8217;s algorithm for this implementation
:param graph:
:return:</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="graph_sna.graph.algorithms.GraphAlgorithms">
<em class="property">class </em><code class="descclassname">graph_sna.graph.algorithms.</code><code class="descname">GraphAlgorithms</code><a class="headerlink" href="#graph_sna.graph.algorithms.GraphAlgorithms" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="graph_sna.graph.algorithms.GraphAlgorithms.SCC_aux">
<code class="descname">SCC_aux</code><span class="sig-paren">(</span><em>u</em>, <em>low</em>, <em>disc</em>, <em>stackMember</em>, <em>st</em>, <em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#graph_sna.graph.algorithms.GraphAlgorithms.SCC_aux" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for strongly connected components.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="graph_sna.graph.algorithms.GraphAlgorithms.average_edges_per_node">
<code class="descname">average_edges_per_node</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#graph_sna.graph.algorithms.GraphAlgorithms.average_edges_per_node" title="Permalink to this definition">¶</a></dt>
<dd><p>An average of the degree of each node.
:param graph:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="graph_sna.graph.algorithms.GraphAlgorithms.collect_flow">
<code class="descname">collect_flow</code><span class="sig-paren">(</span><em>path</em>, <em>residual_capacity_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#graph_sna.graph.algorithms.GraphAlgorithms.collect_flow" title="Permalink to this definition">¶</a></dt>
<dd><p>This method identifies how much flow is available through a given path and removes it from the
residual capacity
:return:</p>
</dd></dl>

<dl class="method">
<dt id="graph_sna.graph.algorithms.GraphAlgorithms.depth_first_search">
<code class="descname">depth_first_search</code><span class="sig-paren">(</span><em>graph</em>, <em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#graph_sna.graph.algorithms.GraphAlgorithms.depth_first_search" title="Permalink to this definition">¶</a></dt>
<dd><p>An implementation of DFS. Primarily used for the discover_components algorithm.
:param graph:
:param source:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="graph_sna.graph.algorithms.GraphAlgorithms.diameter">
<code class="descname">diameter</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#graph_sna.graph.algorithms.GraphAlgorithms.diameter" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum minimum path that exists in the graph
:param graph:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="graph_sna.graph.algorithms.GraphAlgorithms.discover_components">
<code class="descname">discover_components</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#graph_sna.graph.algorithms.GraphAlgorithms.discover_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses DFS to identify components.
:param graph:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="graph_sna.graph.algorithms.GraphAlgorithms.edge_count">
<code class="descname">edge_count</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#graph_sna.graph.algorithms.GraphAlgorithms.edge_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of edges in the graph.
:param graph:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="graph_sna.graph.algorithms.GraphAlgorithms.edmonds_karp">
<code class="descname">edmonds_karp</code><span class="sig-paren">(</span><em>graph</em>, <em>source</em>, <em>sink</em><span class="sig-paren">)</span><a class="headerlink" href="#graph_sna.graph.algorithms.GraphAlgorithms.edmonds_karp" title="Permalink to this definition">¶</a></dt>
<dd><p>An implementeation of Edmonds Karp&#8217;s algorithm for
:param graph:
:param source:
:param sink:
:return:
Psuedocode used: <a class="reference external" href="https://brilliant.org/wiki/edmonds-karp-algorithm/#algorithm-pseudo-code">https://brilliant.org/wiki/edmonds-karp-algorithm/#algorithm-pseudo-code</a></p>
</dd></dl>

<dl class="method">
<dt id="graph_sna.graph.algorithms.GraphAlgorithms.median_path_length">
<code class="descname">median_path_length</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#graph_sna.graph.algorithms.GraphAlgorithms.median_path_length" title="Permalink to this definition">¶</a></dt>
<dd><p>The ‘central’ or median path length.
:param graph:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="graph_sna.graph.algorithms.GraphAlgorithms.min_cut_max_flow">
<code class="descname">min_cut_max_flow</code><span class="sig-paren">(</span><em>graph</em>, <em>source</em>, <em>sink</em><span class="sig-paren">)</span><a class="headerlink" href="#graph_sna.graph.algorithms.GraphAlgorithms.min_cut_max_flow" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the cut along the graph which contains the critical edges for the flow.
As shown in the max-flow min-cut theorem, the weight of this cut equals the maximum amount of flow
that can be sent from the source to the sink in the given network.
:param graph:
:param max_flow:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="graph_sna.graph.algorithms.GraphAlgorithms.minimum_average_path">
<code class="descname">minimum_average_path</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#graph_sna.graph.algorithms.GraphAlgorithms.minimum_average_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the average of the minimum paths of all the nodes.
:param graph:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="graph_sna.graph.algorithms.GraphAlgorithms.mode_path_length">
<code class="descname">mode_path_length</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#graph_sna.graph.algorithms.GraphAlgorithms.mode_path_length" title="Permalink to this definition">¶</a></dt>
<dd><p>The most common path length
:param graph:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="graph_sna.graph.algorithms.GraphAlgorithms.node_count">
<code class="descname">node_count</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#graph_sna.graph.algorithms.GraphAlgorithms.node_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of nodes in the graph. Regardless of whether they are connected or not.
:param graph:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="graph_sna.graph.algorithms.GraphAlgorithms.shortest_path_length">
<code class="descname">shortest_path_length</code><span class="sig-paren">(</span><em>graph</em>, <em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#graph_sna.graph.algorithms.GraphAlgorithms.shortest_path_length" title="Permalink to this definition">¶</a></dt>
<dd><p>An implementation of Dijkstra&#8217;s algorithm which returns the shortest path length from a given node to all other nodes.
:param graph:
:param source:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="graph_sna.graph.algorithms.GraphAlgorithms.strongly_connected_components">
<code class="descname">strongly_connected_components</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#graph_sna.graph.algorithms.GraphAlgorithms.strongly_connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/">https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/</a>
A strongly connected component is maximal subgraph of a directed graph such that for every pair of vertices  u, v
in the subgraph, there is a directed path from u to v and a directed path from v to u.
We use Tarjan&#8217;s algorithm for this implementation
:param graph:
:return:</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-node"></span><span class="target" id="module-graph_sna.graph.node"></span><span class="target" id="module-graph_sna.graph.node"></span></div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Yohan F and Itay P.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="_sources/index.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>